######______伺服器參數______######
#使用12000-12999 空閒Port 建立
server.port=12020
#context path
server.servlet.context-path=/service-basic
#熱部署
spring.devtools.restart.enabled=false
#最高threads 上限
server.tomcat.threads.max=500

server.tomcat.connection-timeout=180s

######______微服務設定______######
#註冊中心 Eureka 上的服務名稱(註冊中心)
spring.application.name=SERVICE-BASIC
#實際主機名稱
eureka.instance.hostname=localhost
#註冊時使用何種名稱?true=IP位/false=主機名稱
eureka.instance.prefer-ip-address=true
#註冊中心 Eureka 是否要註冊?
eureka.client.register-with-eureka=true
#註冊中心 Eureka 取得服務實例的註冊表進行快取
eureka.client.fetch-registry=true
#註冊中心 Eureka 註冊中心位置
eureka.client.service-url.defaultZone=http://localhost:12000/service-center/eureka
#續約更新時間間隔，預設30秒，向server發出心跳，表示此服務存活
eureka.instance.lease-renewal-interval-in-seconds=20
#啟動健康檢查（依賴spring-boot-starter-actuator）
eureka.client.healthcheck.enabled=true


######______SQL設定______######
# create and drop tables and sequences, loads import.sql
#create: 啟動時建立Table, 下次啟動會覆蓋上次的, 故會造成資料遺失
#update: 若無Table則啟動時建立, 若有則視有無變更自動Update
#create-drop:啟動時建立Table, 當次Session關閉則刪除
#spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

#log
# 這兩條對 Hibernate 6 生效
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.orm.jdbc.bind=TRACE
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
# application.properties
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true


# Database Properties
# First PGsql Database Settings - 第一個資料源
pgsql.datasource.driverClassName=org.postgresql.Driver
pgsql.datasource.url=jdbc:postgresql://localhost:5432/dtricloud
pgsql.datasource.username=cloud_admin
pgsql.datasource.password=cloud_579@123

# Second MSsql Database Settings - 第二個資料源
mssql.datasource.driverClassName=com.microsoft.sqlserver.jdbc.SQLServerDriver
mssql.datasource.jdbc-url=jdbc:sqlserver://10.1.90.241:1433;databaseName=DTR_TW;encrypt=false
mssql.datasource.username=user_reader
mssql.datasource.password=dtr@123456
mssql.datasource.platform=mssql

## Hikari連接池配置------詳細配置請訪問：https：//github.com/brettwooldridge/HikariCP
##====== HikariCP 設定 (PGSQL) ======##
# 為 PostgreSQL 專屬的 Hikari 連線池參數，會綁定到 PgsqlConfig 中的 HikariDataSource
# 前提：PgsqlConfig.java 的 DataSource Bean 使用 @ConfigurationProperties("pgsql.datasource.hikari")
# 並以 .type(com.zaxxer.hikari.HikariDataSource.class) 建立

# 連線池名稱（便於監控/日誌辨識）
pgsql.datasource.hikari.pool-name=HikariCP_DTR_PGSQL
# 最小閒置連線數；避免高峰期前完全歸零造成冷啟延遲（依流量調整）
pgsql.datasource.hikari.minimum-idle=5
# 連線池最大連線數；與 DB / 主機資源、應用執行緒相協調
pgsql.datasource.hikari.maximum-pool-size=10
# 借出的連線是否自動提交；大多數情境維持 true（@Transactional 會覆蓋）
pgsql.datasource.hikari.auto-commit=true
# 向池子索取連線的最長等待時間（毫秒）；超時會拋出 SQLTransientConnectionException
pgsql.datasource.hikari.connection-timeout=30000
# 驗證一條連線有效性的最長等待（毫秒）；過短易誤判，過長會拉長延遲
pgsql.datasource.hikari.validation-timeout=5000
# 閒置連線回收時間（毫秒）；適度偏短有助清掉 stale 連線（但勿低於 30s）
pgsql.datasource.hikari.idle-timeout=180000
# 連線最長生命週期（毫秒）；應略短於 DB/防火牆的 idle/TTL 以主動輪替連線
pgsql.datasource.hikari.max-lifetime=1800000
# 連線保活間隔（毫秒）；定期 ping 以提早發現失效連線（避免半開連線）
pgsql.datasource.hikari.keepalive-time=60000
# 測試語句；對 PG 而言 SELECT 1 足夠（亦可依需求改用 isValid() 默認）
pgsql.datasource.hikari.connection-test-query=SELECT 1

##====== HikariCP 設定 (MSSQL) ======##
# 為 MSSQL 專屬的 Hikari 連線池參數，會綁定到 MssqlConfig 中的 HikariDataSource
# 前提：MssqlConfig.java 的 DataSource Bean 使用 @ConfigurationProperties("mssql.datasource.hikari")
# 並以 .type(com.zaxxer.hikari.HikariDataSource.class) 建立

# 連線池名稱（便於監控/日誌辨識）
mssql.datasource.hikari.pool-name=HikariCP_DTR_MSSQL
# 最小閒置連線數；避免高峰期前完全歸零造成冷啟延遲（依流量調整）
mssql.datasource.hikari.minimum-idle=5
# 連線池最大連線數；與 DB / 主機資源、應用執行緒相協調
mssql.datasource.hikari.maximum-pool-size=10
# 借出的連線是否自動提交；大多數情境維持 true（@Transactional 會覆蓋）
mssql.datasource.hikari.auto-commit=true
# 向池子索取連線的最長等待時間（毫秒）；超時會拋出 SQLTransientConnectionException
mssql.datasource.hikari.connection-timeout=30000
# 驗證一條連線有效性的最長等待（毫秒）；過短易誤判，過長會拉長延遲
mssql.datasource.hikari.validation-timeout=5000
# 閒置連線回收時間（毫秒）；適度偏短有助清掉 stale 連線（但勿低於 30s）
mssql.datasource.hikari.idle-timeout=180000
# 連線最長生命週期（毫秒）；應略短於 DB/防火牆的 idle/TTL 以主動輪替連線
mssql.datasource.hikari.max-lifetime=1800000
# 連線保活間隔（毫秒）；定期 ping 以提早發現失效連線（避免半開連線）
mssql.datasource.hikari.keepalive-time=60000
# 測試語句；對 MSSQL 使用 SELECT 1 即可（亦可依需求改用 isValid() 默認）
mssql.datasource.hikari.connection-test-query=SELECT 1

######______Git取得設定______######
#spring.cloud.config.server.git.uri=https://github.com/yiibaicom/spring-cloud-config-server.git

######______郵件服務______######
# 郵件服務帳密
spring.mail.username=dtrsearch@gmail.com
spring.mail.password=whpo tnem adzu udtn
#Password:CBR650R#Honda

# 郵件服務主機
spring.mail.host=smtp.gmail.com
spring.mail.port=587

spring.mail.default-encoding=UTF-8
spring.mail.properties.mail.transport.protocol=smtp

# 驗證 + 強制 TLS
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true

# 若公司有 SSL 檢查/代理，至少信任目標主機（或改為您的代理CA）
spring.mail.properties.mail.smtp.ssl.trust=smtp.gmail.com

# 指定 TLS 協定，避免協商問題
spring.mail.properties.mail.smtp.ssl.protocols=TLSv1.2 TLSv1.3

# 逾時（連線/讀取/寫入）
spring.mail.properties.mail.smtp.connectiontimeout=20000
spring.mail.properties.mail.smtp.timeout=30000
spring.mail.properties.mail.smtp.writetimeout=30000

#對外指定 IP位置(因為有位置限制)
#spring.mail.properties.mail.smtp.localaddress=10.1.90.89
# 測試時使用
spring.mail.properties.mail.smtp.localaddress=10.1.90.101
#暫時不偵測 mail連線狀態
#management.health.mail.enabled=false
# 啟用 JavaMail 除錯輸出（上線後可關閉）
#spring.mail.properties.mail.debug=true


